{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "68b1df01-bfa7-4a8c-beb4-406339e794d1",
   "metadata": {},
   "source": [
    "<h1 style=\"text-align: center\">\n",
    "IPYVOLME: 3D Plotting for Python in the Jupyter Notebook based on IPython Widgets using WebGL\n",
    "</h1>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "92f819ae-4bf7-4193-a1f0-34a03260c081",
   "metadata": {},
   "source": [
    "# Introduction"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "48c832d8-16b9-43a1-8dfa-c600d177a5e8",
   "metadata": {},
   "source": [
    "**Ipyvolume** is a Python library designed for visualizing 3D data directly in Jupyter notebooks with minimal configuration and effort. Built on **IPython widgets** and **WebGL**, it allows users to create interactive 3D visualizations, such as scatter plots, surface plots, volume rendering, and more. **Ipyvolume** leverages the power of **three.js**, a JavaScript library for rendering OpenGL/WebGL-based graphics, ensuring fast and interactive 3D rendering in the browser.\n",
    "\n",
    "The primary use of **Ipyvolume** is for visualizing 3D volumes and glyphs (like 3D scatter plots) within Jupyter notebooks. It's especially useful in scientific computing, data science, and other domains that require in-depth visual exploration of complex 3D datasets. For example, it provides volume rendering of 3D arrays, similar to how **matplotlib’s imshow** renders 2D arrays, allowing users to visualize volumetric data interactively.\n",
    "\n",
    "One of the key features of **Ipyvolume** is its ease of use. Users can quickly create interactive visualizations from numpy arrays or 3D datasets with just a few lines of code. Moreover, **Ipyvolume**’s `volshow` function is tailored for 3D arrays, while other plotting libraries like **yt**, **VTK**, and **Mayavi** can handle more complex, mature, but potentially more difficult-to-use tasks.\n",
    "\n",
    "**Ipyvolume** also supports other 3D visualizations such as scatter plots, quiver plots, mesh plots, and more. It’s especially useful for creating visualizations that allow users to interact with the data, rotating, zooming, and panning to explore the structure of the data from various angles. \n",
    "\n",
    "In this blog we have made a real life model of the solar system using it as we will see ahead. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "515210bd-d7c9-4388-9201-191f851977ce",
   "metadata": {},
   "source": [
    "# Installation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f950d3ed-8fbf-45ac-9046-c7419824abc3",
   "metadata": {},
   "source": [
    "### Using Pip ###"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d946fd35-f018-4394-b493-a66d863e8856",
   "metadata": {},
   "source": [
    "<img src=\"https://cdn.discordapp.com/attachments/1343904302351122538/1343904429274959943/Screenshot_2025-02-24_232736.png?ex=67bef808&is=67bda688&hm=fc2bec44d2f180ad505418da408c3a2594bcb4500d6f47f8838f434725c77fe7&\" alt = \"Pip install\"/>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "06cbf6b6-1f99-4dba-b647-c75be0860034",
   "metadata": {},
   "source": [
    "### Conda/Anaconda ###"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "417b4375-0e57-4b7a-92a1-aa3beb439a89",
   "metadata": {},
   "source": [
    "<img src=\"https://cdn.discordapp.com/attachments/1343904302351122538/1343904429711032350/Screenshot_2025-02-24_233146.png?ex=67bef808&is=67bda688&hm=3f4ebfec97c6cafefe12e17e2b3a4e5065a10cfc77d2d14619f6ce874a48cf39&\"/>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0ccbd16d-2e51-450d-92e8-62ab6c53896f",
   "metadata": {},
   "source": [
    "### For Jupyter lab users ###\n",
    "\n",
    "**The Jupyter lab extension is not enabled by default (yet).**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "65a361c6-89ab-422c-b5af-5cfdeeaf28e9",
   "metadata": {},
   "source": [
    "<img src=\"https://cdn.discordapp.com/attachments/1343904302351122538/1343905950263808081/Screenshot_2025-02-25_1651341.png?ex=67bef973&is=67bda7f3&hm=6a795a76dfd2f16e3a9f9d59e31ce1380d82ff2cacec0a774e9ee6cabcf5cc90&\"/>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "81b3df88-f414-490e-af90-40d27c4147c3",
   "metadata": {},
   "source": [
    "### Pre-notebook 5.3 ###\n",
    "\n",
    "**If you are still using an old notebook version, ipyvolume and its dependend extension (widgetsnbextension) need to be enabled manually. If unsure, check which extensions are enabled:**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c650991f-437f-47ab-9b56-e5799fdb928f",
   "metadata": {},
   "source": [
    "<img src=\"https://cdn.discordapp.com/attachments/1343904302351122538/1343904429983928401/Screenshot_2025-02-24_233528.png?ex=67bef808&is=67bda688&hm=beabab8c10e66d4f61d26ea7589aa87883752eb6c9a2b147c679af0a46e8df51&\"/>\n",
    "<img src=\"https://cdn.discordapp.com/attachments/1343904302351122538/1343904430205960274/Screenshot_2025-02-24_233710.png?ex=67bef808&is=67bda688&hm=1c3f18be24db8d26c7c82ec96c7b62d60d0d3a19146c92b9986f207fbc21ddb8&\"/>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3e85fa92-7cbf-4038-8453-0d7eec3d513d",
   "metadata": {},
   "source": [
    "### Developer installation ###"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7abf734a-4ad7-46cb-8464-9693be066a27",
   "metadata": {},
   "source": [
    "<img src=\"https://cdn.discordapp.com/attachments/1343904302351122538/1343904430495371334/Screenshot_2025-02-24_233917.png?ex=67bef808&is=67bda688&hm=9c391223732f4b393356a8e0e819afa254b1394986e74c69f277f50bef5ad734&\"/>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d8f4bcad-5c7c-4884-b717-5c27dd063fa7",
   "metadata": {},
   "source": [
    "# Key Features of ipyvolume "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "759de2b6-e0df-41b7-9300-640ac700acac",
   "metadata": {},
   "source": [
    "### 1. **Seamless Integration with ipywidgets**  \n",
    "\n",
    "`ipyvolume` integrates effortlessly with `ipywidgets`, allowing users to enhance their 3D visualizations with interactive controls such as sliders, dropdowns, and buttons.  \n",
    "\n",
    "In the example below, we use an `ipywidgets` slider to dynamically adjust the size of points in a scatter plot created with `ipyvolume`:  \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "dfe63779-0398-4db1-9890-ad59384a1395",
   "metadata": {},
   "outputs": [],
   "source": [
    "import ipyvolume as ipv\n",
    "import numpy as np\n",
    "import ipywidgets as widgets\n",
    "import matplotlib.pyplot as plt\n",
    "import bqplot.scales\n",
    "import pythreejs\n",
    "from IPython.display import Image, display"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "57293a6d-2df9-466b-b7ee-3a6448cfa56c",
   "metadata": {},
   "source": [
    "\n",
    "```python\n",
    "n = 100\n",
    "x, y, z = np.random.randn(n), np.random.randn(n), np.random.randn(n)\n",
    "size_slider = widgets.FloatSlider(min=0.1, max=5, step=0.1, value=1.0, description=\"Size\")\n",
    "ipv.figure()\n",
    "scatter = ipv.scatter(x, y, z, size=size_slider.value)\n",
    "\n",
    "def update_size(change):\n",
    "    scatter.size = change['new']\n",
    "    ipv.show()\n",
    "    \n",
    "size_slider.observe(update_size, names='value')\n",
    "display(size_slider)\n",
    "ipv.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4c553544-1df5-48fb-bc43-d651696954d4",
   "metadata": {},
   "source": [
    "<img src=\"https://cdn.discordapp.com/attachments/1343904302351122538/1343925339478556702/msedge_ylGm2QFROW.gif?ex=67bf0b81&is=67bdba01&hm=5d3684723f0f55a2d1b4107782d9a213b9415e3bfa34316049a597b9c3ef2fda&\"/>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "705d0325-949d-4cb2-aa8d-dcbb42a21805",
   "metadata": {},
   "source": [
    "### 2. **Animating Time Series Data**  \n",
    "\n",
    "`ipyvolume` enables dynamic 3D visualizations by supporting animations, making it ideal for representing time-varying data.  \n",
    "It allows users to animate objects over multiple frames and interactively explore how data evolves over time.  \n",
    "\n",
    "In the example below, we create an animated 3D quiver plot where vector directions change over time.  \n",
    "The `animation_control` function provides interactive playback options directly within Jupyter Notebook:  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "c258527c-11b2-4c1d-952a-270259cc7487",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "31fa0819a9904fda97dd3c1e4877ac8c",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(children=[HBox(children=(Play(value=0, interval=200, max=19), IntSlider(value=0, max=19)))], figure=…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import ipyvolume as ipv\n",
    "import numpy as np\n",
    "\n",
    "n = 100\n",
    "x, y, z = np.random.randn(n), np.random.randn(n), np.random.randn(n)\n",
    "t = np.linspace(0, 2 * np.pi, 20)  # 20 time steps\n",
    "u = np.sin(t)[:, None] * np.random.randn(n)\n",
    "v = np.cos(t)[:, None] * np.random.randn(n)\n",
    "w = np.sin(t * 2)[:, None] * np.random.randn(n)\n",
    "\n",
    "ipv.figure()\n",
    "quiver = ipv.quiver(x, y, z, u, v, w, size=5)\n",
    "\n",
    "ipv.animation_control(quiver)\n",
    "ipv.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "33603335-bf99-412e-9c7d-1cac45913b45",
   "metadata": {},
   "source": [
    "### 3. **Integration of bqplot, vaex, and ipyvolume for Interactive Data Visualizations**\n",
    "\n",
    "Combining the strengths of multiple libraries can yield powerful insights when working with large datasets. In this example, we demonstrate how to integrate **vaex**, **bqplot**, and **ipyvolume** in a Jupyter Notebook to explore NYC taxi data:\n",
    "\n",
    "- **vaex** is utilized for fast and memory-efficient processing of large datasets, enabling quick data filtering, aggregation, and analysis.\n",
    "- **bqplot** provides interactive, linked charting that can be used to complement the 3D visualizations.\n",
    "- **ipyvolume** renders the processed data in a dynamic 3D space, where users can explore the spatial distribution of taxi trips.\n",
    "\n",
    "In the example below, we use an `ipywidgets` slider to dynamically adjust the size of points in a plot. This interactivity allows you to explore different aspects of the data by changing visual parameters on the fly. We can further use ipyvolume to visualize it in 3D. But sometimes espesially for very large datasets 2D is better to vizualize. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0d57c7a6-bb76-4443-b9ab-2db729814396",
   "metadata": {},
   "source": [
    "<img src=\"https://cdn.discordapp.com/attachments/1343904302351122538/1343904428838621225/NYC_texi.gif?ex=67bef808&is=67bda688&hm=151401a3c77336c842cea5fc1a987599811463b3f144feacbe67a75321dfbbec&\"/>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "935d4043-7af1-4379-85e2-45b56907cc76",
   "metadata": {},
   "source": [
    "### 4. **3D Line Plots for Trajectories and Curves**  \n",
    "\n",
    "`ipyvolume` allows users to create smooth and interactive 3D line plots, which are useful for visualizing trajectories, paths, and mathematical curves.  \n",
    "By specifying the `x`, `y`, and `z` coordinates, we can plot curves in three-dimensional space with customizable colors and styles.  \n",
    "\n",
    "In the example below, we generate a 3D helix and visualize it using `ipyvolume.plot()`:  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "2316337a-a3ce-429b-9197-75a7805c2225",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "bfab2e71eb0c42309db30da6e7fb08c9",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(figure=Figure(box_center=[0.5, 0.5, 0.5], box_size=[1.0, 1.0, 1.0], camera=PerspectiveCamera(fov=45.…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import ipyvolume as ipv\n",
    "import numpy as np\n",
    "\n",
    "t = np.linspace(0, 4 * np.pi, 100)  # 100 points\n",
    "x, y, z = np.sin(t), np.cos(t), t  # Helix curve\n",
    "\n",
    "ipv.figure()\n",
    "ipv.plot(x, y, z, color=\"red\", linewidth=20)\n",
    "ipv.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a1269d76-9a07-44e8-8dee-a4cd0470b24b",
   "metadata": {},
   "source": [
    "# Examples uses ipyvolume\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "00c2491b-136f-49e5-9163-d4f5c70bdfa2",
   "metadata": {},
   "source": [
    "**These are some examples of different plots made using this library and have been taken from the documentation**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "db8cea56-da37-4701-baad-86beb849769e",
   "metadata": {},
   "source": [
    "First let us import all the neccessary libraries "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "id": "62921c23-50db-48fa-a77d-b52f8cf63a6f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import ipyvolume as ipv\n",
    "import numpy as np\n",
    "import ipywidgets as widgets\n",
    "import matplotlib.pyplot as plt\n",
    "import bqplot.scales\n",
    "import pythreejs\n",
    "from IPython.display import Image, display"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a29fb973-645a-41ad-bea1-76afdb2b5ffa",
   "metadata": {},
   "source": [
    "### A simple scatter plot"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "004d8897-39e3-4673-bef6-57f90a1d9706",
   "metadata": {},
   "source": [
    "**This code generates 1,000 random points in 3D space using a normal distribution and visualizes them using ipyvolume**\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "id": "4e987efc-185c-45f6-8843-88ff389a642a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "c3b8576bff9a408c8cceff6ee3a8c09e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(figure=Figure(box_center=[0.5, 0.5, 0.5], box_size=[1.0, 1.0, 1.0], camera=PerspectiveCamera(fov=45.…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "N = 1000\n",
    "x, y, z = np.random.normal(0, 1, (3, N))\n",
    "fig = ipv.figure()\n",
    "scatter = ipv.scatter(x, y, z)\n",
    "ipv.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c70d61c2-a3b1-4f84-92a1-0e889d2a495c",
   "metadata": {},
   "source": [
    "### Plotting Surface"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c23f9eb6-1e98-4fe8-95a1-2a1e467cec47",
   "metadata": {},
   "source": [
    "**This code creates a 3D surface plot of a function f(u, v) -> (u, v, uv^2) using ipyvolume**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "dd1d92fd-3516-4268-996a-7940fd1b6980",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "2443f0f65e84480b8ce4518e5c43dfca",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(figure=Figure(box_center=[0.5, 0.5, 0.5], box_size=[1.0, 1.0, 1.0], camera=PerspectiveCamera(fov=45.…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# f(u, v) -> (u, v, u*v**2)\n",
    "a = np.arange(-5, 5)\n",
    "U, V = np.meshgrid(a, a)\n",
    "X = U\n",
    "Y = V\n",
    "Z = X*Y**2\n",
    "\n",
    "ipv.figure()\n",
    "ipv.plot_surface(X, Z, Y, color=\"orange\")\n",
    "ipv.plot_wireframe(X, Z, Y, color=\"red\")\n",
    "ipv.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "09df564f-2f77-439d-8f26-1ed33a420006",
   "metadata": {},
   "source": [
    "### Texture mapping"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "149c4db0-595e-49ef-bff9-2a195cf02a8d",
   "metadata": {},
   "source": [
    "**This code applies a PNG image as a texture to a 3D mesh surface using ipyvolume. It downloads an image, maps it to the surface using UV coordinates, and animates the texture shift across 8 frames to create a dynamic effect. The scene is displayed in dark mode with no wireframe.**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "b6d2dead-aaa0-4b7e-9628-ca8f405c17fd",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "8b71c9eebcad40a29d04ae646452b26f",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(children=[HBox(children=(Play(value=0, interval=800, max=7), IntSlider(value=0, max=7)))], figure=Fi…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import PIL.Image\n",
    "import requests\n",
    "import io\n",
    "\n",
    "url = 'https://vaex.io/img/logos/spiral-small.png'\n",
    "r = requests.get(url, stream=True)\n",
    "f = io.BytesIO(r.content)\n",
    "image = PIL.Image.open(f)\n",
    "\n",
    "fig = ipv.figure()\n",
    "ipv.style.use('dark')\n",
    "# we create a sequence of 8 u v coordinates so that the texture moves across the surface.\n",
    "u = np.array([X/5 +np.sin(k/8*np.pi)*4. for k in range(8)])\n",
    "v = np.array([-Y/5*(1-k/7.) + Z*(k/7.) for k in range(8)])\n",
    "mesh = ipv.plot_mesh(X, Z, Y, u=u, v=v, texture=image, wireframe=False)\n",
    "ipv.animation_control(mesh, interval=800, sequence_length=8)\n",
    "ipv.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3a5e7b06-33f0-495a-bb50-9949cb40d4ad",
   "metadata": {},
   "source": [
    "### Basic animation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f631391a-0fab-4b35-9cc4-009a05a9353d",
   "metadata": {},
   "source": [
    "**This code creates an animated 3D scatter plot using ipyvolume, where spheres oscillate based on a decaying cosine wave. The grid points (x, y) determine radial distances r, and the height z evolves over 15 time steps to create a wave-like animation.**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "id": "83a0a25a-1289-462a-9991-a51d26583d8e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "x,y and z are of shape (25, 25)\n",
      "z is of shape (15, 625)\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "9ab3c430c3664a2aaffd4f4ce3d788f8",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(children=[HBox(children=(Play(value=0, interval=200, max=14), IntSlider(value=0, max=14)))], figure=…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# create 2d grids: x, y, and r\n",
    "u = np.linspace(-10, 10, 25)\n",
    "x, y = np.meshgrid(u, u)\n",
    "r = np.sqrt(x**2+y**2)\n",
    "print(\"x,y and z are of shape\", x.shape)\n",
    "\n",
    "# and turn them into 1d\n",
    "x = x.flatten()\n",
    "y = y.flatten()\n",
    "r = r.flatten()\n",
    "\n",
    "# create a sequence of 15 time elements\n",
    "time = np.linspace(0, np.pi*2, 15)\n",
    "z = np.array([(np.cos(r + t) * np.exp(-r/5)) for t in time])\n",
    "print(\"z is of shape\", z.shape)\n",
    "\n",
    "# draw the scatter plot, and add controls with animate_glyphs\n",
    "ipv.figure()\n",
    "s = ipv.scatter(x, z, y, marker=\"sphere\")\n",
    "ipv.animation_control(s, interval=200)\n",
    "ipv.ylim(-3,3)\n",
    "ipv.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8fdf9bae-6ea4-4606-9eb9-cd23560b37be",
   "metadata": {},
   "source": [
    "### Animated quiver"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5b0f0113-c3db-45f2-a832-ce6fc3163474",
   "metadata": {},
   "source": [
    "**This code visualizes an animated 3D vector field using ipyvolume. It loads a predefined animated stream dataset, where each particle has position (x, y, z) and velocity (vx, vy, vz) over time. The quiver plot (ipv.quiver) animates 200 particles over 50 time steps, displaying red arrows that represent their motion in 3D space.**\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "a0373b2c-e35e-458e-a2a6-ebc84816e462",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "shape of steam data (6, 200, 1250)\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "3085fa8fa97e4a10bd919bb80fadb5c3",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(children=[HBox(children=(Play(value=0, interval=200, max=49), IntSlider(value=0, max=49)))], figure=…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import ipyvolume.datasets\n",
    "stream = ipyvolume.datasets.animated_stream.fetch()\n",
    "print(\"shape of steam data\", stream.data.shape) # first dimension contains x, y, z, vx, vy, vz, then time, then particle\n",
    "\n",
    "fig = ipv.figure()\n",
    "# instead of doing x=stream.data[0], y=stream.data[1], ... vz=stream.data[5], use *stream.data\n",
    "# limit to 50 timesteps to avoid having a huge notebook\n",
    "q = ipv.quiver(*stream.data[:,0:50,:200], color=\"red\", size=7)\n",
    "ipv.style.use(\"dark\") # looks better\n",
    "ipv.animation_control(q, interval=200)\n",
    "ipv.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1963b0ff-9334-48a1-8531-a17afcef5e66",
   "metadata": {},
   "source": [
    "### Using scales"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c0af827f-095c-4795-917f-85f91ee6bb2c",
   "metadata": {},
   "source": [
    "**This code creates a 3D scatter plot with logarithmic scaling on the x-axis using ipyvolume and bqplot.scales**\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "b3ee2cdf-48b1-4c96-9ddb-c180e4d73b8d",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "77389ec2d8894e6e885a9df00a293da8",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(figure=Figure(box_center=[0.5, 0.5, 0.5], box_size=[1.0, 1.0, 1.0], camera=PerspectiveCamera(fov=45.…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import bqplot.scales\n",
    "N = 500\n",
    "x, y, z = np.random.normal(0, 1, (3, N))\n",
    "x = 10**x\n",
    "r = np.sqrt(np.log10(x)**2 + y**2 + z**2)\n",
    "scales = {\n",
    "    'x': bqplot.scales.LogScale(min=10**-3, max=10**3),\n",
    "    'y': bqplot.scales.LinearScale(min=-3, max=3),\n",
    "    'z': bqplot.scales.LinearScale(min=-3, max=3),\n",
    "}\n",
    "color_scale = bqplot.scales.ColorScale(min=0, max=3, colors=[\"#f00\", \"#0f0\", \"#00f\"])\n",
    "fig = ipv.figure(scales=scales)\n",
    "scatter = ipv.scatter(x, y, z, color=r, color_scale=color_scale)\n",
    "ipv.view(150, 30, distance=2.5)\n",
    "ipv.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "434573de-12b0-46e7-bd17-d872830216f1",
   "metadata": {},
   "source": [
    "### Bar Charts"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c899b728-5fab-448b-9498-65aab9769089",
   "metadata": {},
   "source": [
    "**This code creates an animated 3D scatter plot in ipyvolume, where color and box size dynamically change based on a cosine-based wave function. The scatter points are box-shaped, with their height (y-dimension) varying over time, and color mapped to the oscillating values.**\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "id": "da18827a-7a41-49ad-a63e-f7271f461369",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "d91795a00e9c48f49e0d835786db4286",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(figure=Figure(box_center=[0.5, 0.5, 0.5], box_size=[1.0, 1.0, 1.0], camera=PerspectiveCamera(fov=45.…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "u_scale = 10\n",
    "Nx, Ny = 30, 15\n",
    "u = np.linspace(-u_scale, u_scale, Nx)\n",
    "v = np.linspace(-u_scale, u_scale, Ny)\n",
    "x, y = np.meshgrid(u, v, indexing='ij')\n",
    "r = np.sqrt(x**2+y**2)\n",
    "x = x.flatten()\n",
    "y = y.flatten()\n",
    "r = r.flatten()\n",
    "\n",
    "time = np.linspace(0, np.pi*2, 15)\n",
    "z = np.array([(np.cos(r + t) * np.exp(-r/5)) for t in time])\n",
    "zz = z\n",
    "\n",
    "fig = ipv.figure()\n",
    "s = ipv.scatter(x, 0, y, aux=zz, marker=\"sphere\")\n",
    "dx = u[1] - u[0]\n",
    "dy = v[1] - v[0]\n",
    "# make the x and z lim half a 'box' larger\n",
    "ipv.xlim(-u_scale-dx/2, u_scale+dx/2)\n",
    "ipv.zlim(-u_scale-dx/2, u_scale+dx/2)\n",
    "ipv.ylim(-1.2, 1.2)\n",
    "ipv.show()\n",
    "\n",
    "# make the size 1, in domain coordinates (so 1 unit as read of by the x-axis etc)\n",
    "s.geo = 'box'\n",
    "s.size = 1\n",
    "s.size_x_scale = fig.scales['x']\n",
    "s.size_y_scale = fig.scales['y']\n",
    "s.size_z_scale = fig.scales['z']\n",
    "s.shader_snippets = {'size':\n",
    " 'size_vector.y = SCALE_SIZE_Y(aux_current); '\n",
    "}\n",
    "\n",
    "s.shader_snippets = {'size':\n",
    " 'size_vector.y = SCALE_SIZE_Y(aux_current) - SCALE_SIZE_Y(0.0) ; '\n",
    "}\n",
    "\n",
    "s.geo_matrix = [dx, 0, 0, 0,   0, 1, 0, 0,   0, 0, dy, 0,  0.0, 0.5, 0, 1]\n",
    "\n",
    "# since we see the boxes with negative sizes inside out, we made the material double sided\n",
    "s.material.side = \"DoubleSide\"\n",
    "# Now also include, color, which containts rgb values\n",
    "color = np.array([[np.cos(r + t), 1-np.abs(z[i]), 0.1+z[i]*0] for i, t in enumerate(time)])\n",
    "color = np.transpose(color, (0, 2, 1)) # flip the last axes\n",
    "s.color = color\n",
    "ipv.animation_control(s, interval=200)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "feb2db74-c847-4911-86fa-66061de88092",
   "metadata": {},
   "source": [
    "### Animation with shadow"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cc0d95d7-283c-42f7-9308-1170bc8f8c66",
   "metadata": {},
   "source": [
    "**This code visualizes an animated 3D vector field using ipyvolume, where quiver arrows represent particle motion from a dataset. It adds lighting effects and planes for better visualization while using a dark theme for contrast. The animation updates at 200ms intervals to show the evolution of the vector field over time.**\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "d8849c6c-b2f6-4aff-93ed-cb8be11afb1e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "shape of steam data (6, 200, 1250)\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f5d820ac544e437d92939cc85b6e3a8e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(children=[HBox(children=(Play(value=0, interval=200, max=199), IntSlider(value=0, max=199)))], figur…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import ipyvolume.datasets\n",
    "stream = ipyvolume.datasets.animated_stream.fetch()\n",
    "print(\"shape of steam data\", stream.data.shape) # first dimension contains x, y, z, vx, vy, vz, then time, then particle\n",
    "\n",
    "fig = ipv.figure()\n",
    "# instead of doing x=stream.data[0], y=stream.data[1], ... vz=stream.data[5], use *stream.data\n",
    "# limit to 50 timesteps to avoid having a huge notebook\n",
    "ipv.material_physical()\n",
    "# q = ipv.quiver(*stream.data[:,0:200:10,:2000:10], color=\"red\", size=7)\n",
    "q = ipv.quiver(*stream.data, color=\"red\", size=7)\n",
    "ipv.style.use(\"dark\") # looks better\n",
    "m = ipv.plot_plane('bottom')\n",
    "m = ipv.plot_plane('back')\n",
    "m = ipv.plot_plane('left')\n",
    "ipv\n",
    "l = ipv.light_directional(position=[20, 50, 20], shadow_camera_orthographic_size=1, far=140, near=0.1);\n",
    "ipv.animation_control(q, interval=200)\n",
    "ipv.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bb60d397-3cb9-4fd4-a67d-a08622ffd3c1",
   "metadata": {},
   "source": [
    "# Interactive Solar System made by us"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6c3c7a12-abce-4b2f-b878-ea9926d6be88",
   "metadata": {},
   "source": [
    "In this section, we demonstrate the power of **ipyvolume** with a fully interactive 3D visualization of our Solar System. Using real astronomical data, we've modeled the eight planets; complete with their colors, sizes, densities, and orbital characteristics to create a realistic simulation of their motion around the Sun.\n",
    "\n",
    "### What Does This Example Showcase?\n",
    "\n",
    "- **Real-World Data Integration:**  \n",
    "  All planetary parameters (such as diameters, orbital distances, and inclinations of orbits) are based on actual measurements, scaled appropriately to create a visually engaging model.The data is taken from all trusted sources, linked in references.\n",
    "\n",
    "- **3D Rendering with ipyvolume:**  \n",
    "  Planets are rendered as 3D spheres using scatter plots, while their orbits are depicted as smooth ellipses drawn with line plots. This combination brings a tangible sense of depth and realism to the simulation.\n",
    "\n",
    "- **Interactive Controls with ipywidgets:**  \n",
    "  A dropdown menu lets you select any planet to view its detailed information (coordinates, size, density, and orbital period) at a given time frame. An accompanying slider lets you navigate through time, watching the dynamic motion of each planet along its orbit.\n",
    "\n",
    "- **Dynamic Animation:**  \n",
    "  The animation control continuously updates the visualization, simulating the planets' movements as they orbit the Sun, demonstrating ipyvolume's capability for smooth, interactive, time-series animations.\n",
    "\n",
    "Run the cell below to see the interactive Solar System in action and explore how ipyvolume can transform your data visualizations!\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "926d81bc-fb19-4348-ad79-5d480fab1f62",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "acdba6a9830b4390a64e80841ecaab4e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Dropdown(description='Select:', options=('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', '…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "756b1e239a5e4ecbbeea945ede12c503",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "IntSlider(value=0, description='Time Frame', max=5999)"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "65bfc1f2fc7948eda8b0eb1c5fea15f2",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HTML(value='\\n    <b>Selected Planet:</b> Mercury <br>\\n    <b>Coordinates:</b> (460.52, 0.00, 0.00) <br>\\n   …"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b9ca5af3c17342878cb8d1daad3bfc78",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "Container(children=[HBox(children=(Play(value=0, max=5999), IntSlider(value=0, max=5999)))], figure=Figure(ani…"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Planet names\n",
    "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n",
    "colors_rgb = np.array([\n",
    "    (0.55, 0.55, 0.55),  # Mercury - Grayish\n",
    "    (0.98, 0.82, 0.15),  # Venus - Pale yellow\n",
    "    (0.0, 0.4, 1.0),     # Earth - Deep blue with land reflections\n",
    "    (0.8, 0.3, 0.1),     # Mars - Reddish brown\n",
    "    (0.9, 0.6, 0.3),     # Jupiter - Orange with brown bands\n",
    "    (0.9, 0.8, 0.6),     # Saturn - Pale yellowish-beige\n",
    "    (0.4, 0.8, 0.9),     # Uranus - Cyan/Light Blue\n",
    "    (0.1, 0.1, 0.7)      # Neptune - Deep Blue\n",
    "])\n",
    "densities = np.array([5.43, 5.24, 5.51, 3.93, 1.33, 0.69, 1.27, 1.64])\n",
    "alpha_values = 0.3 + 0.7 * (densities / np.max(densities))\n",
    "\n",
    "semi_major_axes = np.array([58, 108, 149, 228, 778, 1427, 2871, 4497])*(10**6)\n",
    "eccentricities = np.array([0.206, 0.007, 0.017, 0.093, 0.048, 0.056, 0.046, 0.010])\n",
    "inclinations = np.array([7.00, 3.4, 0.00, 1.8, 1.3, 2.5, 0.8, 1.8]) * (np.pi / 180)  # Convert to radians\n",
    "\n",
    "real_distances = np.array([0.31, 0.72, 0.98, 1.38, 4.95, 9.01, 18.28, 29.80])*1.496*(10**8)\n",
    "real_diameter = np.array([4878, 12100, 12756, 6794, 142800, 120000, 52400, 48400])\n",
    "real_radii = real_diameter/2\n",
    "sun_radius = 696340 \n",
    "\n",
    "scale_factor_distance = 0.00001\n",
    "scale_factor_size = 0.0001\n",
    "\n",
    "scaled_distances = scale_factor_distance*real_distances\n",
    "scaled_radii = scale_factor_size*real_radii\n",
    "\n",
    "scaled_semi_major_axes = semi_major_axes * scale_factor_distance  # Scaled distances\n",
    "\n",
    "orbital_periods = np.array([88, 225, 365, 687, 4333, 10759, 30687, 60190])\n",
    "\n",
    "angular_speeds = 50*((2 * np.pi) / orbital_periods)\n",
    "time = np.linspace(0, 1000 * np.pi, 6000)\n",
    "\n",
    "x, y, z = [], [], []  # For x, y, z positions over time using elliptical orbits\n",
    "for i in range(len(planets)):\n",
    "    theta = angular_speeds[i] * time  # Angle for each time step\n",
    "    r = (scaled_semi_major_axes[i] * (1 - eccentricities[i]**2)) / (1 + eccentricities[i] * np.cos(theta))\n",
    "    \n",
    "    x_orbit = r * np.cos(theta)\n",
    "    y_orbit = r * np.sin(theta)\n",
    "    z_orbit = np.zeros_like(theta)  # Initially in the XY plane\n",
    "    \n",
    "    y_tilted = y_orbit * np.cos(inclinations[i]) - z_orbit * np.sin(inclinations[i])  # for inclination\n",
    "    z_tilted = y_orbit * np.sin(inclinations[i]) + z_orbit * np.cos(inclinations[i])\n",
    "    \n",
    "    x.append(x_orbit)\n",
    "    y.append(y_tilted)\n",
    "    z.append(z_tilted)\n",
    "\n",
    "x = np.array(x).T\n",
    "y = np.array(y).T\n",
    "z = np.array(z).T\n",
    "\n",
    "fig = ipv.figure()\n",
    "\n",
    "planet_scatter = ipv.scatter(x, y, z, size=scaled_radii, marker=\"sphere\", color=colors_rgb, opacity = alpha_values)\n",
    "# for i, (radius, density, color) in enumerate(zip(scaled_radii, densities, colors)):\n",
    "#     ipv.scatter([i*10], [0], [0], size=radius, marker=\"sphere\", color=color, alpha=density/6)\n",
    "\n",
    "theta_full = np.linspace(0, 2 * np.pi, 100)  # 100 points for smooth ellipses\n",
    "for i in range(len(planets)):\n",
    "    r_full = (scaled_semi_major_axes[i] * (1 - eccentricities[i]**2)) / (1 + eccentricities[i] * np.cos(theta_full))\n",
    "    \n",
    "    x_orbit = r_full * np.cos(theta_full)\n",
    "    y_orbit = r_full * np.sin(theta_full)\n",
    "    z_orbit = np.zeros_like(theta_full)\n",
    "    \n",
    "    y_tilted = y_orbit * np.cos(inclinations[i]) - z_orbit * np.sin(inclinations[i])\n",
    "    z_tilted = y_orbit * np.sin(inclinations[i]) + z_orbit * np.cos(inclinations[i])\n",
    "    \n",
    "    ipv.plot(x_orbit, y_tilted, z_tilted, color=\"gray\")\n",
    "\n",
    "dropdown = widgets.Dropdown(options=planets, description=\"Select:\")\n",
    "info_label = widgets.HTML(value = \"Select a planet to see details\")\n",
    "\n",
    "def update_info(change):\n",
    "    selected_planet = dropdown.value\n",
    "    index = planets.index(selected_planet)\n",
    "    frame = frame_slider.value\n",
    "    current_x = x[frame, index]\n",
    "    current_y = y[frame, index]\n",
    "    current_z = z[frame, index]\n",
    "\n",
    "    planet_radius = real_radii[index]  # Actual radius in km\n",
    "    planet_density = densities[index]  # g/cm³\n",
    "    planet_orbital_period = orbital_periods[index]  # Days\n",
    "    \n",
    "    planet_info = f\"\"\"\n",
    "    <b>Selected Planet:</b> {selected_planet} <br>\n",
    "    <b>Coordinates:</b> ({current_x:.2f}, {current_y:.2f}, {current_z:.2f}) <br>\n",
    "    <b>Size (Radius):</b> {planet_radius} km <br>\n",
    "    <b>Density:</b> {planet_density} g/cm³ <br>\n",
    "    <b>Orbital Period:</b> {planet_orbital_period} days\n",
    "    \"\"\"\n",
    "    \n",
    "    info_label.value = planet_info  # Update display\n",
    "\n",
    "frame_slider = widgets.IntSlider(min=0, max=len(time)-1, step=1, description=\"Time Frame\")\n",
    "frame_slider.observe(update_info, names=\"value\")\n",
    "update_info(None)\n",
    "\n",
    "dropdown.observe(update_info, names=\"value\")\n",
    "display(dropdown, frame_slider, info_label)\n",
    "\n",
    "ipv.animation_control(planet_scatter, interval=100)\n",
    "ipv.style.use(\"dark\") \n",
    "ipv.show()\n",
    "\n",
    "\n",
    "#the below code is just to rotate the whole thing 360 degrees\n",
    "\n",
    "# control = pythreejs.OrbitControls(controlling=fig.camera)\n",
    "# fig.controls = control\n",
    "# control.autoRotate = True\n",
    "# fig.render_continuous = True\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e6c3464a-f283-4a5c-9df7-927a067c935a",
   "metadata": {},
   "source": [
    "# Use Cases of `ipyvolume` "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8876e39c-93eb-43c9-8eb3-cfcaea87d474",
   "metadata": {},
   "source": [
    "### 1) Visualizing 3D Scalar or Vector Fields  \n",
    "**Examples:**  \n",
    "- Render **MRI scan data** as a 3D volume to analyze anatomical structures.  \n",
    "- Simulate **fluid flow** in a pipe and visualize velocity vectors with quiver plots.  \n",
    "\n",
    "**How to Use:**  \n",
    "- Use `ipv.volshow` to render volumetric data (e.g., **density, temperature**).  \n",
    "- Apply **color maps and opacity adjustments** to highlight regions of interest.  \n",
    "\n",
    "---  \n",
    "\n",
    "### 2) Physics Simulations & Trajectory Analysis  \n",
    "**Examples:**  \n",
    "- Simulate **gravitational interactions** in a multi-body system (e.g., **solar system orbits**).  \n",
    "- Track **particle paths** in a magnetic field or **Brownian motion**.  \n",
    "\n",
    "**How to Use:**  \n",
    "- Animate **time-dependent data** with `ipv.plot` and `ipv.animation_control`.  \n",
    "- Overlay 3D arrows (`ipv.quiver`) to show **force vectors**.  \n",
    "- Use `ipv.pylab.style.box()` to add **contextual axes and grids**.  \n",
    "\n",
    "---  \n",
    "\n",
    "### 3) Interactive Educational Demonstrations  \n",
    "**Examples:**  \n",
    "- Visualize **3D surfaces** (e.g., paraboloids, sine waves) with adjustable parameters.  \n",
    "- Demonstrate **gradient descent optimization** in 3D loss landscapes.  \n",
    "\n",
    "**How to Use:**  \n",
    "- Plot **parametric surfaces** using `ipv.plot_surface`.  \n",
    "- Add **interactive widgets** (e.g., sliders) to modify equations in real time.  \n",
    "- Use `ipv.figure()` to create **linked views** for multi-angle exploration.  \n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3195e10d-42f5-4798-ab2f-09dfcd9e0fcf",
   "metadata": {},
   "source": [
    "# Conclusion  \n",
    "\n",
    "In an age where **data science is advancing at an unprecedented pace**, the `ipyvolume` library stands out as a **transformative tool** for visualizing **complex 3D datasets** with remarkable **interactivity and clarity**.  \n",
    "\n",
    "From **crafting basic scatter plots** to **engineering intricate animations**, `ipyvolume` bridges the gap between **raw data** and **actionable insights**.  \n",
    "\n",
    "### Real-World Applications  \n",
    "- **Celestial Mechanics**:\n",
    "    - Enables the creation of a **scaled-down solar system model** using real-world **orbital data** as shown in the above hands on example.  \n",
    "- **Aerodynamics & Industrial Design**:  \n",
    "  - **Quiver plots** visualize **vector fields**, crucial for **analyzing airflow dynamics**.  \n",
    "  - Applied in **advancements in aerodynamics and industrial design**.  \n",
    "\n",
    "### Unveiling Hidden Dimensions & Empowering Data Exploration  \n",
    "Beyond its **technical prowess**, `ipyvolume` acts as a **lens**, revealing **hidden patterns** in data that **static visualizations** often obscure. Whether in **academic research, machine learning, or engineering simulations**, this library is **more than just a tool**—it **empowers users** to **interact with data in immersive, innovative ways**, solidifying its role as an **essential asset** in the ever-evolving landscape of **data-driven discovery**.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7a3a329a-6168-4188-b9b6-f11dd299a818",
   "metadata": {},
   "source": [
    "# References \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "28c97848-19ce-41c2-a5c6-d694bfce4e00",
   "metadata": {},
   "source": [
    "[1] M. A. Breddels, \"ipyvolume Documentation,\" ipyvolume.readthedocs.io, 2017. [Online]. Available: [https://ipyvolume.readthedocs.io/](https://ipyvolume.readthedocs.io/). [Accessed: Feb. 25, 2025].\n",
    "\n",
    "[2] M. A. Breddels, \"Multivolume Rendering in Jupyter with ipyvolume: Cross-Language 3D Visualization,\" Towards Data Science, Sep. 14, 2018. [Online]. Available: [https://medium.com/towards-data-science/multivolume-rendering-in-jupyter-with-ipyvolume-cross-language-3d-visualization-64389047634a](https://medium.com/towards-data-science/multivolume-rendering-in-jupyter-with-ipyvolume-cross-language-3d-visualization-64389047634a). [Accessed: Feb. 25, 2025].\n",
    "\n",
    "[3] Royal Museums Greenwich, \"Solar system data,\" Royal Museums Greenwich, [Online]. Available: [https://www.rmg.co.uk/stories/topics/solar-system-data](https://www.rmg.co.uk/stories/topics/solar-system-data). [Accessed: Feb. 25, 2025].\n",
    "\n",
    "[4] Lumen Learning, \"Physical and orbital data for the planets,\" Lumen Learning - Astronomy, [Online]. Available: [https://courses.lumenlearning.com/suny-astronomy/chapter/physical-and-orbital-data-for-the-planets/](https://courses.lumenlearning.com/suny-astronomy/chapter/physical-and-orbital-data-for-the-planets/). [Accessed: Feb. 25, 2025].\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
